## 1、讲一讲项目中避免OOM都有哪些方法？ ##
1. I/O流用完及时关闭
2. 定义内部类时一定要注意看当前类是否持有Activity引用或者当前类是否是Activity。
3. 一般情况下要用Context时最好用ApplicationContext，必须用ActivityContext时要注意Context引用回收。
4. 将View注入其他类时，确保该View引用在用完后被回收。
5. Activity中注册监听与反注册最好成对出现。
6. 尽量使用图片加载框架(ImageLoader/Picasso/Glide...)加载图片，因为使用图片加载框架不需要去考虑图片Bitmap回收问题
7. 不用框架加载图片时，请用LruCache管理图片缓存列表。
8. 如果以上两种方式都不用，一定要确保Bitmap使用完后合理回收。
## 2、简单讲讲HashMap底层数据结构和原理，HashMap优点是什么，缺点又是什么？ ##
* HashMap底层实现采用了哈希表， 哈希表的基本结构就是“数组+链表”。
* 当添加一个元素(key-value)时，首先计算key的hash值，以此确定插入数组中的位置，
  但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，
  他们在数组的同一位置，就形成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。
   JDK8中，当链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。
* 取数据过程：（1）获得key的hashcode，通过hash()散列算法得到hash值，进而定位到数组的位置。(2) 在链表上挨个比较key对象。 调用equals()方法，将key对象和链表上所有节点的key对象进行比较，直到碰到返回true的节点对象为止。(3) 返回equals()为true的节点对象的value对象。
*  扩容问题：HashMap的位桶数组，初始大小为16。实际使用时，显然大小是可变的。如果位桶数组中的元素达到(0.75*数组 length)， 就重新调整数组大小变为原来2倍大小。扩容很耗时。扩容的本质是定义新的更大的数组，并将旧数组内容挨个拷贝到新数组中。
## 3、Java对象的生命周期，并说说每个生命周期具体做了什么？ ##
### 创建阶段（Created） ###
* 为对象分配存储空间
* 开始构造对象
* 从超类到子类对static成员进行初始化
* 超类成员变量按顺序初始化，递归调用超类的构造方法
* 子类成员变量按顺序初始化，子类构造方法调用
### 应用阶段（In Use） ###
* 对象至少被一个强引用持有着
### 不可见阶段（Invisible） ###
* 当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。
### 不可达阶段（Unreachable） ###
* 对象处于不可达阶段是指该对象不再被任何强引用所持有。
### 收集阶段（Collected） ###
* 当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。
### 终结阶段 ###
* 当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。
## 4、设计模式的六个基本原则是什么，并简单解释一下每个原则。 ##
1. 开闭原则
2. 单一原则
3. 依赖倒置原则
4. 接口隔离原则
5. 里式替换原则
6. 迪米特原则
## 5、列举出你项目中用到过的设计模式并说说是哪些实际场景。 ##
## 6、线程池创建时的7个参数分别代表什么意思？ ##
1. corePoolSize 线程池核心线程大小
2. maximumPoolSize 线程池最大线程数量
3. keepAliveTime 空闲线程存活时间
4. unit 空闲线程存活时间单位
5. workQueue 工作队列
6. threadFactory 线程工厂
7. handler 拒绝策略
## 7、讲讲JMM（内存模型）是怎样的。 ##
由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而Java内存模型中规定所有变量都存储在主内存,主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存 ,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,彼此间的通讯(传值) 必须通过主内存来完成。
## 8、Java为何会有线程安全问题？如何解决？ ##
因为JVM内存模型的原因使得多线程访问统一变量不准确的问题。解决办法可以通过对访问读写进行加锁
## 9、从点击应用的图标到第一个页面显示出来中间的流程是怎样的？ ##
①点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；

②system_server进程接收到请求后，向zygote进程发送创建进程的请求；

③Zygote进程fork出新的子进程，即App进程；

④App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；

⑤system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；

⑥App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；

⑦主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。

⑧到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。
## 10、讲一讲你之前项目中的屏幕适配方案或者你了解的方案。 ##
今日头条屏幕适配方案的核心原理在于，根据以下公式算出 density
当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = density
density 的意思就是 1 dp 占当前设备多少像素
大家都知道，不管你在布局文件中填写的是什么单位，最后都会被转化为 px，系统就是通过上面的方法，将你在项目中任何地方填写的单位都转换为 px 的
所以我们常用的 px 转 dp 的公式 dp = px / density，就是根据上面的方法得来的，density 在公式的运算中扮演着至关重要的一步
## 11、谈一谈你对自定义view的理解和自定义view的时候应该注意哪些问题。 ##
* 支持wrap content
* 支持padding
* 尽量不要在view中使用handler，因为view本身就提供了post系列的方法，完全可以替代handler使用
* view中如果有线程或动画，需要及时停止
* 主要特殊情况下的view滑动冲突
## 12、谈谈你对Handler机制的理解。 ##
Handler允许你发送Message/Runnable到线程的消息队列(MessageQueue)中，每个Handler实例和一个线程以及那个线程的消息队列相关联。当你创建一个Handler时应该和一个Looper进行绑定（主线程默认已经创建Looper了，子线程需要自己创建Looper），它向Looper的对应的消息队列传送Message/Runnable同时在那个Looper所在线程处理对应的Message/Runnable。
## 13、Android为何会使用binder来进行进程间通信。 ##
* （1）从性能的角度 数据拷贝次数：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。
* （2）从稳定性的角度Binder是基于C/S架构的，简单解释下C/S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。
* （3）从安全的角度传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。
## 14、HTTPS相对于HTTP的优势在哪里？ ##
* 内容加密：采用混合加密技术，中间者无法直接查看明文内容
* 验证身份：通过证书认证客户端访问的是自己的服务器
* 保护数据完整性：防止传输的内容被中间人冒充或者篡改